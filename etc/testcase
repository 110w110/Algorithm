

bool test(int blankIndex, int testNum){

    x_box = x/3*3
    y_box = y/3*3

    i=0~8 돌려서 [i][x]랑 [y][i]에 같은 값이 있으면서 같은 [y][x]자리 아니면 거짓 리턴
    y_box~ybox+3사이랑 x_box~x_box+3 사이에 같은 값이면서 같은 좌표 아니면 거짓 리턴

    for(i=0;i<9;i++){

        if(resultSudoku[i][x]==testNum&&y!=i)return false;
        if(resultSudoku[y][i]==testNum&&x!=i)return false;
    }
    for(i=y_Box;i<y_Box+3;i++){
        for(j=x_Box;j<x_Box+3;j++){
            if(resultSudoku[i][j]==testNum&&j!=x&&i!=y)return false;
        }
    }

    return true;   //test pass -> return 0
}

bool backTracking(int blankIndex){
    인덱스>=빈칸수 -> 탈출

    빈칸 좌표에 1~9까지 순서대로 넣어봄
        test(빈칸인덱스) -> 오류나면 다음으로 (모순되는지 확인)
        오류가 안나면 다음 빈칸인덱스 백트래킹(다음빈칸) 호출
        리턴값이 0이면 원래 인덱스로 복귀
        리턴값이 1이면 참값 리턴
    리턴 0

    int i=0;
    for(i=0;i<9;i++){       //1~9까지 숫자를 대입해본다
        if(test(blankIndex, i+1)){
            //일단 blank index번째는 i로 설정
            resultSudoku[blankAddr[0][blankIndex]][blankAddr[1][blankIndex]]=i+1;
            //일단 설정 해봤을 때 이후 과정들도 재귀적으로 확인하여 모순이 있는지 체크
            bool resultBackTracking=backTracking(blankIndex+1);
            if(!resultBackTracking){
                //blank index번째 다시 0으로 복귀
                resultSudoku[blankAddr[0][blankIndex]][blankAddr[1][blankIndex]]=0;
            }
            else{
                //return
                return true;
            }
        }

    }

    return 0;   //0이 리턴되었다면 완성이 안됐다는것
}


int main() {
    for(n=0;n<nTimes;n++){

        스도쿠판 세팅

        (x,y)가 0인 좌표 따로 저장해둠, 몇개인지 확인

        백트래킹(0) <-0은 빈칸좌표 인덱스 0번부터 시작

        if(backTracking(0)){cout << "sudoku " << n+1 << endl; printSudoku();}
    }

    fin.close();
}



예제 입력 1
103000509
002109400
000704000
300502006
060000050
700803004
000401000
009205800
804000107
예제 출력 1
143628579
572139468
986754231
391542786
468917352
725863914
237481695
619275843
854396127


문제
요즘 종수는 아두이노를 이용해 "Robots"이라는 게임을 만들었다. 종수는 아두이노 한대를 조정하며, 미친 아두이노를 피해다녀야 한다. 미친 아두이노는 종수의 아두이노를 향해 점점 다가온다. 하지만, 미친 아두이노의 움직임은 예측할 수 있다.

게임은 R×C크기의 보드 위에서 이루어지며, 아래와 같은 5가지 과정이 반복된다.

먼저, 종수가 아두이노를 8가지 방향(수직,수평,대각선)으로 이동시키거나, 그 위치에 그대로 놔둔다.
종수의 아두이노가 미친 아두이노가 있는 칸으로 이동한 경우에는 게임이 끝나게 되며, 종수는 게임을 지게 된다.
미친 아두이노는 8가지 방향 중에서 종수의 아두이노와 가장 가까워 지는 방향으로 한 칸 이동한다. 즉, 종수의 위치를 (r1,s1), 미친 아두이노의 위치를 (r2, s2)라고 했을 때, |r1-r2| + |s1-s2|가 가장 작아지는 방향으로 이동한다.
미친 아두이노가 종수의 아두이노가 있는 칸으로 이동한 경우에는 게임이 끝나게 되고, 종수는 게임을 지게 된다.
2개 또는 그 이상의 미친 아두이노가 같은 칸에 있는 경우에는 큰 폭발이 일어나고, 그 칸에 있는 아두이노는 모두 파괴된다.
종수의 시작 위치, 미친 아두이노의 위치, 종수가 움직이려고 하는 방향이 주어진다. 입력으로 주어진 방향대로 종수가 움직였을 때, 보드의 상태를 구하는 프로그램을 작성하시오. 중간에 게임에서 지게된 경우에는 몇 번째 움직임에서 죽는지를 구한다.

입력
첫째 줄에 보드의 크기 R과 C가 주어진다. (1 ≤ R, C ≤ 100)

다음 R개 줄에는 C개의 문자가 주어지며, 보드의 상태이다. '.'는 빈 칸, 'R'은 미친 아두이노, 'I'는 종수의 위치를 나타낸다.

마지막 줄에는 길이가 100을 넘지않는 문자열이 주어지며, 종수가 움직이려고 하는 방향이다. 5는 그 자리에 그대로 있는 것을 나타내고, 나머지는 아래와 같은 방향을 나타낸다.



보드를 벗어나는 입력은 주어지지 않는다.

출력
중간에 게임이 끝나는 경우에는 "kraj X"를 출력한다. X는 종수가 게임이 끝나기 전 까지 이동한 횟수이다. 그 외의 경우에는 보드의 상태를 입력과 같은 형식으로 출력한다.

예제 입력 1
4 5
I....
.....
.R.R.
.....
6
예제 출력 1
.I...
.RR..
.....
.....
예제 입력 2
9 10
..........
.........R
..........
R.........
R...I.....
R.........
..........
.........R
....R.....
5558888
예제 출력 2
....I.....
....R.....
..........
..........
..........
..........
..........
..........
..........
예제 입력 3
12 8
...I....
........
........
........
........
RR......
......RR
R......R
........
........
........
...R....
66445394444162
예제 출력 3
kraj 11






4 5
I....
.....
.....
..RRR
6664

8 8
........
....R...
........
.......R
........
........
....I...
.......R
778524

12 7
R......
.......
.......
.......
.......
...I...
.......
.......
.......
.......
.......
R.....R
464453955134646


8 8
R......R
.R...RR.
..R..RR.
........
.....R..
......R.
....I...
.......R
1444

답

........
........
........
........
R..R....
RRR.....
RRR.....
IRRR....



4 4
RR..
.R..
....
..I.
4