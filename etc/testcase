

bool test(int blankIndex, int testNum){

    x_box = x/3*3
    y_box = y/3*3

    i=0~8 돌려서 [i][x]랑 [y][i]에 같은 값이 있으면서 같은 [y][x]자리 아니면 거짓 리턴
    y_box~ybox+3사이랑 x_box~x_box+3 사이에 같은 값이면서 같은 좌표 아니면 거짓 리턴

    for(i=0;i<9;i++){

        if(resultSudoku[i][x]==testNum&&y!=i)return false;
        if(resultSudoku[y][i]==testNum&&x!=i)return false;
    }
    for(i=y_Box;i<y_Box+3;i++){
        for(j=x_Box;j<x_Box+3;j++){
            if(resultSudoku[i][j]==testNum&&j!=x&&i!=y)return false;
        }
    }

    return true;   //test pass -> return 0
}

bool backTracking(int blankIndex){
    인덱스>=빈칸수 -> 탈출

    빈칸 좌표에 1~9까지 순서대로 넣어봄
        test(빈칸인덱스) -> 오류나면 다음으로 (모순되는지 확인)
        오류가 안나면 다음 빈칸인덱스 백트래킹(다음빈칸) 호출
        리턴값이 0이면 원래 인덱스로 복귀
        리턴값이 1이면 참값 리턴
    리턴 0

    int i=0;
    for(i=0;i<9;i++){       //1~9까지 숫자를 대입해본다
        if(test(blankIndex, i+1)){
            //일단 blank index번째는 i로 설정
            resultSudoku[blankAddr[0][blankIndex]][blankAddr[1][blankIndex]]=i+1;
            //일단 설정 해봤을 때 이후 과정들도 재귀적으로 확인하여 모순이 있는지 체크
            bool resultBackTracking=backTracking(blankIndex+1);
            if(!resultBackTracking){
                //blank index번째 다시 0으로 복귀
                resultSudoku[blankAddr[0][blankIndex]][blankAddr[1][blankIndex]]=0;
            }
            else{
                //return
                return true;
            }
        }

    }

    return 0;   //0이 리턴되었다면 완성이 안됐다는것
}


int main() {
    for(n=0;n<nTimes;n++){

        스도쿠판 세팅

        (x,y)가 0인 좌표 따로 저장해둠, 몇개인지 확인

        백트래킹(0) <-0은 빈칸좌표 인덱스 0번부터 시작

        if(backTracking(0)){cout << "sudoku " << n+1 << endl; printSudoku();}
    }

    fin.close();
}



예제 입력 1
103000509
002109400
000704000
300502006
060000050
700803004
000401000
009205800
804000107
예제 출력 1
143628579
572139468
986754231
391542786
468917352
725863914
237481695
619275843
854396127



문제
RGB거리에는 집이 N개 있다.
거리는 선분으로 나타낼 수 있고,
1번 집부터 N번 집이 순서대로 있다.

집은 빨강, 초록, 파랑 중 하나의 색으로 칠해야 한다.
각각의 집을 빨강, 초록, 파랑으로 칠하는 비용이 주어졌을 때,
아래 규칙을 만족하면서 모든 집을 칠하는 비용의 최솟값을 구해보자.

1번 집의 색은 2번, N번 집의 색과 같지 않아야 한다.
N번 집의 색은 N-1번, 1번 집의 색과 같지 않아야 한다.
i(2 ≤ i ≤ N-1)번 집의 색은 i-1, i+1번 집의 색과 같지 않아야 한다.
입력
첫째 줄에 집의 수 N(2 ≤ N ≤ 1,000)이 주어진다.
둘째 줄부터 N개의 줄에는 각 집을 빨강, 초록, 파랑으로 칠하는 비용이 1번 집부터 한 줄에 하나씩 주어진다.
집을 칠하는 비용은 1,000보다 작거나 같은 자연수이다.

출력
첫째 줄에 모든 집을 칠하는 비용의 최솟값을 출력한다.

예제 입력 1
3
26 40 83
49 60 57
13 89 99
예제 출력 1
110
예제 입력 2
3
1 100 100
100 1 100
100 100 1
예제 출력 2
3
예제 입력 3
3
1 100 100
100 100 100
1 100 100
예제 출력 3
201
예제 입력 4
6
30 19 5
64 77 64
15 19 97
4 71 57
90 86 84
93 32 91
예제 출력 4
208
예제 입력 5
8
71 39 44
32 83 55
51 37 63
89 29 100
83 58 11
65 13 15
47 25 29
60 66 19
예제 출력 5
253



문제
서양 장기인 체스에는 대각선 방향으로 움직일 수 있는 비숍(bishop)이 있다. < 그림 1 >과 같은 정사각형 체스판 위에 B라고 표시된 곳에 비숍이 있을 때 비숍은 대각선 방향으로 움직여 O로 표시된 칸에 있는 다른 말을 잡을 수 있다.



< 그림 1 >

그런데 체스판 위에는 비숍이 놓일 수 없는 곳이 있다. < 그림 2 >에서 체스판에 색칠된 부분은 비숍이 놓일 수 없다고 하자. 이와 같은 체스판에 서로가 서로를 잡을 수 없도록 하면서 비숍을 놓는다면 < 그림 3 >과 같이 최대 7개의 비숍을 놓을 수 있다.  색칠된 부분에는 비숍이 놓일 수 없지만 지나갈 수는 있다.



< 그림 2 >



< 그림 3 >

정사각형 체스판의 한 변에 놓인 칸의 개수를 체스판의 크기라고 한다. 체스판의 크기와 체스판 각 칸에 비숍을 놓을 수 있는지 없는지에 대한 정보가 주어질 때, 서로가 서로를 잡을 수 없는 위치에 놓을 수 있는 비숍의 최대 개수를 구하는 프로그램을 작성하시오.

입력
첫째 줄에 체스판의 크기가 주어진다. 체스판의 크기는 10이하의 자연수이다. 둘째 줄부터 아래의 예와 같이 체스판의 각 칸에 비숍을 놓을 수 있는지 없는지에 대한 정보가 체스판 한 줄 단위로 한 줄씩 주어진다. 비숍을 놓을 수 있는 곳에는 1, 비숍을 놓을 수 없는 곳에는 0이 빈칸을 사이에 두고 주어진다.

출력
첫째 줄에 주어진 체스판 위에 놓을 수 있는 비숍의 최대 개수를 출력한다.

예제 입력 1
5
1 1 0 1 1
0 1 0 0 0
1 0 1 0 1
1 0 0 0 0
1 0 1 1 1
예제 출력 1
7

예제 입력 1
So when I die (the [first] I will see in (heaven) is a score list).
[ first in ] ( first out ).
Half Moon tonight (At least it is better than no Moon at all].
A rope may form )( a trail in a maze.
Help( I[m being held prisoner in a fortune cookie factory)].
([ (([( [ ] ) ( ) (( ))] )) ]).
 .
.
예제 출력 1
yes
yes
no
no
no
yes
yes


문제
외판원 순회 문제는 영어로 Traveling Salesman problem (TSP) 라고 불리는 문제로 computer science 분야에서 가장 중요하게 취급되는 문제 중 하나이다. 여러 가지 변종 문제가 있으나, 여기서는 가장 일반적인 형태의 문제를 살펴보자.

1번부터 N번까지 번호가 매겨져 있는 도시들이 있고, 도시들 사이에는 길이 있다. (길이 없을 수도 있다) 이제 한 외판원이 어느 한 도시에서 출발해 N개의 도시를 모두 거쳐 다시 원래의 도시로 돌아오는 순회 여행 경로를 계획하려고 한다. 단, 한 번 갔던 도시로는 다시 갈 수 없다. (맨 마지막에 여행을 출발했던 도시로 돌아오는 것은 예외) 이런 여행 경로는 여러 가지가 있을 수 있는데, 가장 적은 비용을 들이는 여행 계획을 세우고자 한다.

각 도시간에 이동하는데 드는 비용은 행렬 W[i][j]형태로 주어진다. W[i][j]는 도시 i에서 도시 j로 가기 위한 비용을 나타낸다. 비용은 대칭적이지 않다. 즉, W[i][j] 는 W[j][i]와 다를 수 있다. 모든 도시간의 비용은 양의 정수이다. W[i][i]는 항상 0이다. 경우에 따라서 도시 i에서 도시 j로 갈 수 없는 경우도 있으며 이럴 경우 W[i][j]=0이라고 하자.

N과 비용 행렬이 주어졌을 때, 가장 적은 비용을 들이는 외판원의 순회 여행 경로를 구하는 프로그램을 작성하시오.

입력
첫째 줄에 도시의 수 N이 주어진다. (2 ≤ N ≤ 16)
 다음 N개의 줄에는 비용 행렬이 주어진다.
 각 행렬의 성분은 1,000,000 이하의 양의 정수이며, 갈 수 없는 경우는 0이 주어진다.
  W[i][j]는 도시 i에서 j로 가기 위한 비용을 나타낸다.

항상 순회할 수 있는 경우만 입력으로 주어진다.

출력
첫째 줄에 외판원의 순회에 필요한 최소 비용을 출력한다.

예제 입력 1
4
0 10 15 20
5 0 9 10
6 13 0 12
8 8 9 0
예제 출력 1
35


0000